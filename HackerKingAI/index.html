<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hacker King AI — Fake Generator</title>
  <style>
    body { font-family: system-ui, Arial; background:#0b0b0b; color:#e9e9e9; display:flex; gap:24px; padding:24px; }
    .left { width:360px }
    .controls { display:flex; flex-direction:column; gap:8px; margin-top:12px }
    button, input[type=range], select { padding:8px; border-radius:8px; border:1px solid #222; background:#111; color:#eee }
    canvas { background:#222; display:block; image-rendering: pixelated; border-radius:8px; margin-top:12px }
    label { font-size:13px; color:#bbb }
    .small { font-size:13px; color:#aaa }
  </style>
</head>
<body>
  <div class="left">
    <h1>Hacker King AI (fake)</h1>
    <div class="small">Mixes & randomly distorts chosen images from your Pictures2 folder.</div>

    <div class="controls">
      <button id="generateBtn">Generate</button>
      <button id="downloadBtn">Download PNG</button>

      <label>Resolution
        <select id="resolution">
          <option value="32">32×32</option>
          <option value="64" selected>64×64 (retro)</option>
          <option value="128">128×128</option>
          <option value="256">256×256</option>
        </select>
      </label>

      <label>Mix strength <input id="mixRange" type="range" min="0" max="1" step="0.05" value="0.6"></label>
      <label>Noise amount <input id="noiseRange" type="range" min="0" max="1" step="0.01" value="0.12"></label>
      <label>Glitchiness <input id="glitchRange" type="range" min="0" max="1" step="0.01" value="0.25"></label>
      <label><input id="seedRandom" type="checkbox" checked> Random seed each generate</label>
      <div class="small">Tip: Low resolution + pixelated = retro bad-AI look.</div>
    </div>
  </div>

  <div>
    <canvas id="out" width="64" height="64"></canvas>
    <div style="display:flex; gap:8px; margin-top:8px">
      <canvas id="preview1" width="128" height="128" style="width:128px;height:128px;border-radius:6px"></canvas>
      <canvas id="preview2" width="128" height="128" style="width:128px;height:128px;border-radius:6px"></canvas>
    </div>
  </div>

<script>
/*
  Hacker King AI - Fake generator
  - Place this file in HackerKingAI/index.html
  - Pictures assumed to be at ../Pictures2/HackerKingAI/
  - Edit paths below if needed.
*/

const IMAGE_PATHS = [
  '../Pictures2/HackerKingAI/FRIES_Orca.jpeg',
  '../Pictures2/HackerKingAI/Tiktok1.jpg',
  '../Pictures2/HackerKingAI/Untitled1003.png',
  '../Pictures2/HackerKingAI/Messenger_creation_824529923060121.jpeg'
];

const outCanvas = document.getElementById('out');
const outCtx = outCanvas.getContext('2d', { willReadFrequently: true });
const preview1 = document.getElementById('preview1');
const preview2 = document.getElementById('preview2');
const pctx1 = preview1.getContext('2d');
const pctx2 = preview2.getContext('2d');

const imgs = [];
let rngSeed = 12345;

// Simple seeded RNG (Mulberry32)
function seededRng(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function rand(r) { return r(); }

function loadImages(paths) {
  return Promise.all(paths.map(p => new Promise((resolve, reject) => {
    const im = new Image();
    im.crossOrigin = 'anonymous';
    im.src = p;
    im.onload = () => { resolve(im); };
    im.onerror = (e) => { console.warn('Image failed:', p, e); resolve(createFallback(p)); };
  })));
}

function createFallback(path) {
  // in case image missing: small colored placeholder
  const c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#3a3';
  ctx.fillRect(0,0,256,256);
  ctx.fillStyle='#000';
  ctx.fillText('missing',10,20);
  const img = new Image();
  img.src = c.toDataURL();
  return img;
}

// image utilities
function drawImageCover(ctx, img, w, h) {
  // cover strategy: fill canvas, cropping as necessary
  const iw = img.width, ih = img.height;
  const rs = Math.max(w/iw, h/ih);
  const sw = w/rs, sh = h/rs;
  const sx = Math.max(0, (iw - sw)/2);
  const sy = Math.max(0, (ih - sh)/2);
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);
}

// pixelate by scaling down and back up
function pixelate(canvas, size) {
  const w = canvas.width, h = canvas.height;
  const tmp = document.createElement('canvas'); tmp.width = size; tmp.height = size;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(canvas, 0, 0, size, size);
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(tmp, 0, 0, w, h);
}

// add gaussian-ish noise
function addNoise(ctx, amount, rng) {
  const w = ctx.canvas.width, h = ctx.canvas.height;
  const id = ctx.getImageData(0,0,w,h);
  const d = id.data;
  for (let i=0;i<d.length;i+=4) {
    const n = (rand(rng)-0.5)*255*amount;
    d[i] = Math.max(0, Math.min(255, d[i] + n));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
  }
  ctx.putImageData(id,0,0);
}

// posterize / reduce color bits
function posterize(ctx, levels=4) {
  const w = ctx.canvas.width, h = ctx.canvas.height;
  const id = ctx.getImageData(0,0,w,h);
  const d = id.data;
  for (let i=0;i<d.length;i+=4) {
    d[i] = Math.floor(d[i] / (256/levels)) * (256/levels);
    d[i+1] = Math.floor(d[i+1] / (256/levels)) * (256/levels);
    d[i+2] = Math.floor(d[i+2] / (256/levels)) * (256/levels);
  }
  ctx.putImageData(id,0,0);
}

// silly sine displacement (x axis)
function sineDisplace(canvas, amplitude=4, frequency=8, rng) {
  const w = canvas.width, h = canvas.height;
  const src = canvas.getContext('2d').getImageData(0,0,w,h);
  const dst = new ImageData(w,h);
  const sd = src.data, dd = dst.data;
  for (let y=0;y<h;y++) {
    const shift = Math.floor((Math.sin((y/frequency) + rand(rng)*6.28) * amplitude));
    for (let x=0;x<w;x++) {
      const sx = Math.max(0, Math.min(w-1, x + shift));
      const si = (y*w + sx)*4;
      const di = (y*w + x)*4;
      dd[di] = sd[si]; dd[di+1] = sd[si+1]; dd[di+2] = sd[si+2]; dd[di+3] = sd[si+3];
    }
  }
  canvas.getContext('2d').putImageData(dst, 0,0);
}

// channel shift: copy one channel offset
function channelShift(ctx, offsetX, offsetY) {
  const canvas = ctx.canvas;
  const w = canvas.width, h = canvas.height;
  const id = ctx.getImageData(0,0,w,h);
  const d = id.data;
  const tmp = new Uint8ClampedArray(d.length);
  tmp.set(d);
  const shift = (offsetY * w + offsetX) * 4;
  for (let i=0;i<d.length;i+=4) {
    const rIdx = i;
    const gIdx = i+1;
    const bIdx = i+2;
    const idxR = Math.max(0, Math.min(d.length-4, rIdx + shift));
    const idxG = Math.max(0, Math.min(d.length-4, gIdx - shift));
    const idxB = Math.max(0, Math.min(d.length-4, bIdx + Math.floor(shift/2)));
    d[rIdx] = tmp[idxR] || tmp[rIdx];
    d[gIdx] = tmp[idxG] || tmp[gIdx];
    d[bIdx] = tmp[idxB] || tmp[bIdx];
  }
  ctx.putImageData(id,0,0);
}

// block glitch: swap random rectangles
function blockGlitch(ctx, amount, rng) {
  const w = ctx.canvas.width, h = ctx.canvas.height;
  const swaps = Math.floor(amount * 8) + 1;
  for (let s=0;s<swaps;s++){
    const bw = Math.max(2, Math.floor(rand(rng) * w * 0.4));
    const bh = Math.max(2, Math.floor(rand(rng) * h * 0.2));
    const sx = Math.floor(rand(rng) * (w-bw));
    const sy = Math.floor(rand(rng) * (h-bh));
    const dx = Math.floor(rand(rng) * (w-bw));
    const dy = Math.floor(rand(rng) * (h-bh));
    const id = ctx.getImageData(sx,sy,bw,bh);
    ctx.putImageData(id,dx,dy);
  }
}

// mix images by drawing them with random offsets and alpha
function mixImages(canvas, chosen, mixStrength, rng) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  // create temporary canvas to draw each source and transform
  chosen.forEach((img, idx) => {
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    // random translate/scale/rotate small amounts
    tctx.save();
    const tx = Math.floor((rand(rng)-0.5) * w * 0.1);
    const ty = Math.floor((rand(rng)-0.5) * h * 0.1);
    const scale = 1 + (rand(rng)-0.5) * 0.3;
    const rot = (rand(rng)-0.5) * 0.2;
    tctx.translate(w/2 + tx, h/2 + ty);
    tctx.rotate(rot);
    tctx.scale(scale, scale);
    tctx.translate(-w/2, -h/2);
    drawImageCover(tctx, img, w, h);
    tctx.restore();

    // draw to final with varying alpha
    ctx.globalAlpha = 0.5 * (mixStrength) * (1 - idx*0.07) + 0.25 * (rand(rng));
    ctx.drawImage(tmp,0,0);
  });
  ctx.globalAlpha = 1.0;
}

// main generate function
function generate(rseed = null) {
  const res = parseInt(document.getElementById('resolution').value, 10);
  outCanvas.width = res; outCanvas.height = res;
  preview1.width = res; preview1.height = res;
  preview2.width = res; preview2.height = res;

  let seed;
  if (document.getElementById('seedRandom').checked || rseed === null) {
    seed = Math.floor(Math.random() * 1000000);
  } else seed = rseed;
  const r = seededRng(seed);

  // pick 2-3 random images
  const count = 2 + Math.floor(rand(r)*2); // 2 or 3
  const chosen = [];
  const idxs = [];
  while (chosen.length < count) {
    const i = Math.floor(rand(r) * imgs.length);
    if (!idxs.includes(i)) { idxs.push(i); chosen.push(imgs[i]); }
  }

  const mixStrength = parseFloat(document.getElementById('mixRange').value);
  mixImages(outCanvas, chosen, mixStrength, r);

  // apply effects in random order based on sliders
  const noise = parseFloat(document.getElementById('noiseRange').value);
  const glitch = parseFloat(document.getElementById('glitchRange').value);

  // do a pixelated pass sometimes
  if (rand(r) > 0.4) {
    // choose pixel size depending on res
    const pixelSize = Math.max(2, Math.floor(res / (4 + Math.floor(rand(r)*6))));
    pixelate(outCanvas, Math.max(8, Math.floor(res / pixelSize)));
  }

  // apply channel shift
  if (rand(r) < 0.9) channelShift(outCtx, Math.floor((rand(r)-0.5)*res*0.06), Math.floor((rand(r)-0.5)*res*0.06));

  // noise
  if (noise > 0.01) addNoise(outCtx, noise * (0.8 + rand(r)*0.6), r);

  // sine displacement
  if (rand(r) < 0.8) sineDisplace(outCanvas, Math.max(1, Math.floor(res * (0.02 + rand(r)*0.06))), Math.max(6, Math.floor(6 + rand(r)*12)), r);

  // block glitch
  if (glitch > 0.02 && rand(r) < 0.9) blockGlitch(outCtx, glitch, r);

  // posterize occasionally
  if (rand(r) < 0.7) posterize(outCtx, 3 + Math.floor(rand(r)*5));

  // draw effect previews (scaled up with pixelated rendering)
  pctx1.clearRect(0,0,preview1.width,preview1.height);
  pctx1.imageSmoothingEnabled = false;
  pctx1.drawImage(outCanvas, 0,0, preview1.width, preview1.height);

  pctx2.clearRect(0,0,preview2.width,preview2.height);
  pctx2.imageSmoothingEnabled = false;
  // slight added color shift for second preview
  pctx2.save();
  pctx2.globalAlpha = 0.95;
  pctx2.drawImage(outCanvas, 0,0, preview2.width, preview2.height);
  pctx2.restore();

  console.log('Generated with seed', seed);
  return seed;
}

// download current canvas
function downloadCanvas() {
  const a = document.createElement('a');
  a.href = outCanvas.toDataURL('image/png');
  a.download = 'hackerkingai.png';
  a.click();
}

// init UI & load images
document.getElementById('generateBtn').addEventListener('click', () => generate());
document.getElementById('downloadBtn').addEventListener('click', downloadCanvas);

loadImages(IMAGE_PATHS).then(results => {
  imgs.push(...results);
  // draw first two previews from sources so user sees originals
  pctx1.clearRect(0,0,preview1.width,preview1.height);
  pctx1.drawImage(imgs[0], 0,0, preview1.width, preview1.height);
  pctx2.drawImage(imgs[1 % imgs.length], 0,0, preview2.width, preview2.height);

  // initial generate
  generate(Math.floor(Math.random()*1000000));
}).catch(e => {
  console.error('Images load error', e);
});

</script>
</body>
</html>
